	Node()

next_=nullptr; //node

	Node(T& an_item)
an_item=0;

	Node(const T& an_item, Node<T>* next_node)
item_=an_iten;
next_=next_node;

	void SetItem(const T& an_item)
item_=an_item
	
	void setNext(Node<T>* next_node)
next->next_node;

	
	LinkedBag() O(1)
item_count_=0;
head_ptr_=nullptr;

	~inkedBag() O(n) worst case due to memory

	add() O(1)
check if lsit not emppty !isempty()
make new node 
new node->setItem(new_entry)
newnode point to head newnode->SetNext(head_ptr)
head=newnode
count++;
	
	std::vector<F> toVector() const O(n)
make vector 	std::vector<T> bagcontents
make new node pointing at head
newnode=head;  	Node<T>* cur_ptr=head_ptr_;
while new node not last in list
newnode_->getItem() pushes to vector
new node points to next node
new_node=new_node->getNext()

	getPointerTo(const T& an_entry) const O(n)
make new node
node point to head
newnode=head
while new node not in last list loop
newnode_->getItem()
check if equals to an_entry
return the newnode of the item

	
//help with remove, clear

	bool LinkedBag<T>::remove(const T& an_entry)  O(n)
Node<T>* entry = getPointerTo(an_entry); gives where node is for an_entry
while entry not at last
entry set item of head get item      	entry_ptr->setItem(head_ptr_->getItem());
make new node Delete equals to head       Node<T>* node_delete=head_ptr_;
head points to next node 			head_ptr_=head_ptr_->getNext();
node delete setNext(nullptr)			node_delete->setNext(nullPtr);
delete nodedelete					delete node_delete;
nodedelete=nullptr				node_delete=nullptr;
count--;


	void clear()  O(n)
make new delete node point to head		Node<T>* node_delete=head_ptr_;
whiel head not last
head gerts next pointer			      head_ptr_=head_ptr_->getNext();
new delete node setNext(nullptr)		node_delete->SetNext(nullptr);
delete node delete				delete node_delete;
node delete=headptr				node_delete=head_ptr_;
itemcount=0

	void swap(vector<string>& x, vector<string>& y)
{
 vector<string> temp = std::move(x);
 x = std::move(y);
 y = std::move(temp);
}

	bool List<T>::insert(size_t position, const T& new_element){

make new node containing new element 	Node<T>* newNode=new Node<T>(new_element)
get node location of position			Node<T>* pos_ptr=getPointerTo(position)

//if first is the only one in list
    if (first==nullptr){
       new node setNext(nullptr) only one in list
	 new node setPrevious(nullptr) only one in list
	 first->setPrevious(newNode)
	 first=newnode
    }

    //if po_ptr is first node
    else if(pos_ptr=first){
      new node SetNext(first)
	new node SetPrevious(nullptr)
	first->setPrevious(newnide)
	first=new node
    }

    else if(pos_ptr=nullptr){
       new node_>setNext(nullptr) last one in list
	 new node->setPrevious(last)
	 last->setNext(newnode)
	 last=new node;
    }

    else{
	 newnode=setNext(pos_ptr)
	 newnode->setPrevious(pos_ptr_>getPrevoius())
	 posptr->getPrevious()->setNext(newnode)
	 posptr->setPrevious(newnode)
    }

bool List <T>::remove(size_t position)
	
make node pos_ptr equal to getPointerTo(position)
if (pos_ptr == first_) { 	//if pos node equal to first node
        // Remove first node
        first_ = pos_ptr -> getNext();	//first equals to pos next node
        first_ -> setPrevious(nullptr);	//first setprevoud nullptr becuase first node
        // Return node to the system	
        pos_ptr -> setNext(nullptr);	//pos ptr setnext nullptr deleting node
        delete pos_ptr;			//delete node
        pos_ptr = nullptr;		//pospotr=nullptr
      }
else if (pos_ptr == last_) {
        //remove last_ node
        last_ = pos_ptr -> getPrevious();
        last_ -> setNext(nullptr);
        // Return node to the system
        pos_ptr -> setPrevious(nullptr);
        delete pos_ptr;
        pos_ptr = nullptr;
} else {
        //Remove from the middle
        pos_ptr -> getPrevious() -> setNext(pos_ptr -> getNext());
        pos_ptr -> getNext() -> setPrevious(pos_ptr -> getPrevious());
        // Return node to the system
        pos_ptr -> setNext(nullptr);
        pos_ptr -> setPrevious(nullptr);
        delete pos_ptr;
        pos_ptr = nullptr;

virtual void ConvertToPixelArrat() const==0 polymprlhism pure virtual function


	linear search O(n)
for loop see where item is

	binary search O(log(n))
two variables low=0, high=last item in vector
loop whilie(low<high)
middle variable= (high+low)/2
if item >middle place
increment low=mid+1
else item <middle place
decrement high=mid-1
return mid

	Selection sort void selectionSort(const std::vector<Comparable>& the_array)
int size = the_array.size();
for (int first = 0; first < size; first++)
int smallest_index = findIndexOfSmallest(the_array, first, size);
std::swap(the_array[smallest_index], the_array[first]);	


	//Bubble Sort run time is O(n2) Worst Case. O(n) best Case
	void bubbleSort(const std::vector<Comparable>& the_array)
	
int size = the_array.size();
bool swapped = true; // Assume unsorted
int pass = 1;
while (swapped && (pass < size))
{
swapped = false;
for (int index = 0; index < size - pass; index++)
{
if (the_array[index] > the_array[index+1])
{
std::swap(the_array[index], the_array[index+1]); //swap
swapped = true; // indicates array not yet sorted
}// end if
} // end for
pass++;
} // end while
} // end bubbleSort


	Insertion sort O(n2) Worst Case. O(n) best case
void insertionSort(const std::vector<Comparable>& the_array)
{
int size = the_array.size();
for (int unsorted = 1; unsorted < size; unsorted++)
{
int current = unsorted; //the index of the item currently being inserted
while ((current > 0) && (the_array[current - 1] > the_array[current]))
{
std::swap(the_array[current], the_array[current - 1]); // swap
current--;
} // end while
} // end for
} // end insertionSort


	void recursiveReverse(string &str)
make stack
loop through string
push elements itno stack
loop through string
elemnts equal to top of stack
pop elements

	Stack
for(char ch : st)
{
if ch is an open parenthesis character
push it on the stack
else if ch is a close parenthesis character
if it matches the top of the stack
pop the stack
else
return unbalanced
// else it is not a parenthesis
}
if stack is empty
return balanced
else
return unbalanced

	LinkedStack<ItemType>::~LinkedStack()
while not empty
pop stack

	 LinkedStack<ItemType>::isEmpty()
return topPtr==nullptr

	LinkedStack<ItemType>::push(const ItemType& newItem)
make new node equal to node with new Itemtype, topPtr 	Node <T>*newnode= new node<T>(newItem,TopPtr) 
topPointer of stack equals to node			topPointer=newnode
new node becomes nullptr				newnode=nullptr

	LinkedStack<ItemType>::pop()
if stack not empty			!isEmpty()
make delete node equal to topNode	Node<T>* deleteNode=topNode
topNode points to next Node		topNode=topNode->getNext()
Delete Node points to nullptr		deleteNode->getNext(nullptr)
delete node				delete Node
node = nulllptr				Node=nullptr


	Queue  bool LinkedQueue<ItemType>::enqueue(const ItemType& newEntry)
make new node have newEntry		Node<T>* newNode=new Node<T>(newEntry)
if not empty queue			!isEmpty()
frontPointer=newNode			frontPtr=newNode
else					Else
backPointer->setNext(newnodePtr)	backPointer_>setNext(newNodePtr)
backPointer=newNodePtr			backPointer=newNodePtr

	bool LinkedQueue<ItemType>::dequeue()
if not empty				!isEmpty()
delete node equals frotn Node		Node<T>* NodeDelete=front Node
front node gets next node		frontNode->getNext()
node delete points to nullptr		NodeDelete_>setNext(Nullptr)
delete node delete			delete NodeDelete
node delete=nullptr			NodeDelete=nullptr


	Trees	Search(bs_tree, item)   Worst Case O(H)
if(bs_tree is empty)
item not found
else if item ==root
return root
else if item<root
search(T L, item)
else
Search(T R, item)

	add(bs_tree, item) Worst Case O(H)
if(bs_tree,item)
item=root
else if item<root
add(T L, item)
else
add(T R, item)

	inorder(bs_tree) Worst Case O(H)
if(bs_tree not empty)
inorder(T L)
visit Root
inOrder(T R)
		













































































